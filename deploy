#!/bin/sh
# Deploy dotfiles in a new system

set -e

systems="macos linux illumos freebsd msys"
shared_dirs="bin .config .ssh"

#############################################################################
# help
# 
# Prints usage information and exits
#############################################################################
help() {
  printf "Usage: ${0} <system> [-d]\n" 
  printf "Where system must be one of the following:\n"
  for l_he_system in $systems; do
    printf "$l_he_system "
  done
  printf "\n\n"
  printf "  -d: Dry-run. Only lists changes to be made.\n"
  exit 1
}

#############################################################################
# get_abs_path <path>
# 
# Returns the absolute path of the file or directory passed as an argument
#############################################################################
get_abs_path() {
  if [ -d "$1" ]; then
    (cd "$1" && pwd -P)
  else
    l_gp_dir=$(dirname "$1")
    l_gp_file=$(basename "$1")
    l_gp_abs_dir=$(cd "$l_gp_dir" && pwd -P)
    printf "${l_gp_abs_dir}/${l_gp_file}"
  fi
}

#############################################################################
# is_in_list <item> <list>
# 
# Returns 0 if $item is in the space separated $list
#############################################################################
is_in_list() {
  for l_il_memb in $2; do
    if [ "$1" = "$l_il_memb" ]; then
      return 0
    fi
  done
  return 1
}

#############################################################################
# run_cmd <command> ...
# 
# Prints the passed arguments and if $dry_run is not set, executes them as
# well
#############################################################################
run_cmd() {
  echo "$@"
  if ! [ "$dry_run" = "true" ]; then
    "$@"
  fi
}

#############################################################################
# link_item <src> <dst> <bkp>
# 
# Creates a symbolic link to $src in $dst. If $dst exists it is moved to a
# backup directory in $bkp, preserving the original directory hierarchy.
#############################################################################
link_item() {
  l_li_src="$1"
  l_li_dst="$2"
  l_li_bkp="$3"
  l_li_dst_path=$(dirname "$l_li_dst")

  if [ ! -d "$l_li_dst_path" ]; then
    run_cmd mkdir -p "$l_li_dst_path"
  fi  

  if [ -e "$l_li_dst" ] && [ ! -L "$l_li_dst" ]; then
    backup_item "$l_li_dst" "$l_li_bkp"
  fi

  if [ -L "$l_li_dst" ]; then
    run_cmd rm "$l_li_dst"
  fi

  run_cmd ln -s "$l_li_src" "$l_li_dst"
}

#############################################################################
# backup_item <src> <dst>
# 
# Moves $src into the backup directory $dst. This function extracts the path
# to $src starting from $HOME and replicates it in $dst.
#############################################################################
backup_item() {
  l_bi_src="$1"
  l_bi_dst_root="$2"
  l_bi_dst="${l_bi_dst_root}/${l_bi_src#$HOME/}"
  l_bi_dst_path=$(dirname "$l_bi_dst")

  if [ ! -d "${l_bi_dst_path}" ]; then
    run_cmd mkdir -p "${l_bi_dst_path}"
  fi

  run_cmd mv "$l_bi_src" "$l_bi_dst"
}

#############################################################################
# process_directory <src> <dst>
# 
# Loops through the contents of $src and links each to $HOME/$dst. If any
# shared directory is found it calls itself recursively again to process it.
#
# The first time the function is called $dst should be empty because the
# source files are stored referencing $HOME as the root directory.
# When the function calls itself recursively it appends the destination
# directory inside $HOME being processed to $dst to reproduce the file
# hierarchy correctly.
#############################################################################
process_directory() {
  for l_pd_rel_src in "$1"/*; do
    [ -e "$l_pd_rel_src" ] || continue

    l_pd_item=$(basename "${l_pd_rel_src}")
    if [ "${l_pd_item}" != "${l_pd_item#_}" ]; then
      l_pd_item=".${l_pd_item#_}"
    fi

    if is_in_list "$l_pd_item" "$shared_dirs"; then
      process_directory "${l_pd_rel_src}" "${2}${l_pd_item}/"
      continue
    fi

    l_pd_src=$(get_abs_path "${l_pd_rel_src}")
    l_pd_dst="${HOME}/${2}${l_pd_item}"

    link_item "${l_pd_src}" "${l_pd_dst}" "${bkppath}"
  done
}

#############################################################################
# Main logic
#############################################################################
bkppath="${HOME}/.dotfiles.old-$(date +%Y-%m-%d-%H:%M:%S)"

if [ $# -lt 1 ]; then
  help
elif ! is_in_list "$1" "$systems"; then
  help
fi

if [ "$2" = "-d" ]; then
  dry_run="true"
fi

if ! [ $dry_run ]; then
  printf "This script will link the dotfiles in this repository to your home \
directory, replacing your current configuration. Files that are replaced will \
be backed up to %s\n\nDo you wish to continue? (Y/n)" "${bkppath}"

  read proceed
  case "$proceed" in
    [Yy]*)
      ;;
    *)
      printf "Aborting\n"
      exit 0
      ;;
  esac
fi

# The script expects to be run from where it is originally located in the 
# repository. i.e in the same level as the dotfile source directories.
cd $(dirname "$0")

install_dirs="common $1"

for dir in $install_dirs; do
  root="./${dir}/home"
  process_directory "$root" ""
done

printf "\nCompleted configuration for %s\n" "${1}"
if [ "$dry_run" = "true" ]; then
  printf "The -d option was used, so no changes have been made to the filesystem\n"
fi
